# $Id: critics_de.properties 335 2010-02-21 09:54:00Z BraunHarald $
#******************************************************************************
# Copyright (c) 2009 Contributors - see below
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#    mvw
#******************************************************************************
#
# Some portions of this file was previously release using the BSD License:
#
# Copyright (c) 2004 The Regents of the University of California. All
# Rights Reserved. Permission to use, copy, modify, and distribute this
# software and its documentation without fee, and without a written
# agreement is hereby granted, provided that the above copyright notice
# and this paragraph appear in all copies.  This software program and
# documentation are copyrighted by The Regents of the University of
# California. The software program and documentation are supplied "AS
# IS", without any accompanying services from The Regents. The Regents
# does not warrant that the operation of the program will be
# uninterrupted or error-free. The end-user understands that the program
# was developed for research purposes and is advised not to rely
# exclusively on the program for any reason.  IN NO EVENT SHALL THE
# UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
# SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
# ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
# THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
# PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
# CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
# UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#
# Created from UMLCognitiveResourceBundle_de.java
#
# The keys are generated from the class names of the classes that use them.
#
critics.CrAlreadyRealizes-desc = Die markierte Klasse realisiert bereits \
	indirekt eine oder mehrere Schnittstellen durch Vererbung. Es gibt keinen \
	Grund, diese nochmals zu implementieren. \n\nEs ist immer eine gute Idee, \
	den Entwurf zu vereinfachen. Sie m\u00F6chten vielleicht dieses \
	Pr\u00FCfkriterium unbearbeitet lassen, wenn Sie deutlich \
	machen wollen, da\u00df die markierte Klasse diese Schnittstelle \
	implementiert.\n\nUm dieses Problem zu beheben, markieren Sie die \
	Implementierung (die punktierte Linie mit der weissen, dreieckigen \
	Pfeilspitze) und dr\u00fccken Sie die Tastenkombination \"Strg-Entf\".
critics.CrAlreadyRealizes-head = Entfernen Sie die unn\u00f6tige \
	Implementierung von \"<ocl>self</ocl>\"
critics.CrAssocNameConflict-desc = Jedes Element eines Namensraumes mu\u00df \
	einen eindeutigen Namen haben. \n\nEine klare und unzweideutige \
	Namensgebung ist ein Schl\u00fcsselelement f\u00FCr die Codegenerierung, die \
	Verst\u00e4ndlichkeit und die Wartbarkeit des Entwurfes. \n\nUm dieses \
	Problem zu beseitigen, klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie markieren die Elemente und \u00e4ndern die Namen im \
	Registerblatt \"Eigenschaften\".
critics.CrAssocNameConflict-head = L\u00f6sen Sie den Konflikt bei den \
	Assoziationsnamen auf
critics.CrAttrNameConflict-desc = Attribute m\u00fcssen eindeutig \
	unterscheidbare Namen haben. Dieses Problem kann auch durch vererbte \
	Attribute entstehen. \n\nKlare und eindeutige Namen sind ein \
	Schl\u00fcsselelement bei der Codegenerierung und beim Erstellen eines \
	verst\u00e4ndlichen und pflegbaren Entwurfes.\n\nZur Beseitigung des \
	Problemes, klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie \
	markieren eines der betroffenen Attribute dieser Klasse und \u00e4ndern \
	seinen Namen.
critics.CrAttrNameConflict-head = Um einen Konflikt zu vermeiden, \u00c4ndern \
	Sie den Namen des Attributes.
critics.CrCallWithoutReturn-desc = Jede Aufruf- oder Sende-Aktion erfordert \
	eine R\u00FCckgabe-Aktion.\n Aber diese Assoziation hat keine 
	R\u00FCckgabe-Aktion.\n
critics.CrCallWithoutReturn-head = Vermisse R\u00FCckgabe-Aktionen
critics.CrCircularAssocClass-desc = Assoziierte Klassen d\u00FCrfen keine \
	Rolle enthalten, die sich wiederum direkt auf die Klasse bezieht.
critics.CrCircularAssocClass-head = Schleife bei Assoziation
critics.CrCircularComposition-desc = Kompositionsbeziehungen (schwarze \
	Diamanten) d\u00fcrfen keine Schleifen bilden. \n\nF\u00fcr die \
	Code-Generierung und f\u00fcr die Richtigkeit des Entwurfes wird eine \
	zul\u00e4ssige Aggregationshierarchie ben\u00f6tigt. \n\nZur Beseitigung \
	des Problemes, klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, 
	Sie w\u00e4hlen manuell eine der Assoziationen in der Schleife aus und \
	entfernen diese.
critics.CrCircularComposition-head = Entfernen Sie die zirkulare Komposition.
critics.CrCircularInheritance-desc = Vererbte Assoziationen d\u00FCrfen keine \
	Schleifen aufweisen. \n\nEine g\u00FCltige Klassen-Vererbungs-Hierachie wird \
	f\u00FCr die Codegenerierung und f\u00FCr einen korrekten Entwurf ben\u00F6tigt.
critics.CrCircularInheritance-head = Enfernen Sie die zirkulare Vererbung in \
	<ocl>self</ocl>
critics.CrClassMustBeAbstract-desc = Klassen, die abstrakte Methoden von \
	Basisklassen oder Schnittstellen enthalten oder vererben, m\u00fcssen als \
	abstrakt gekennzeichnet werden.\n\nDie Entscheidung, welche Klassen \
	abstrakt oder konkret sind, ist ein Schl\u00fcsselelement f\u00fcr den \
	Entwurf der Klassenhierarchie.\n\nZur Beseitigung des Problemes, verwenden \
	Sie die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren die Klasse von \
	Hand und verwenden das Registerblatt \"Eigenschaften\", um das \
	Schl\u00fcsselwort \"abstract\" hinzuzuf\u00fcgen. Oder, Sie \
	\u00fcberschreiben jede abstrakte Methode, die von der Basisklasse oder \
	der Schnittstelle vererbt wurde.
critics.CrClassMustBeAbstract-head = Die Klasse <ocl>self</ocl> mu\u00df \
	abstrakt sein
critics.CrClassWithoutComponent-desc = In Verteilungsdiagrammen befinden sich \
	Klassen normalerweise innerhalb von Komponenten
critics.CrClassWithoutComponent-head = Klassen befinden sich normalerweise \
	innerhalb von Komponenten
critics.CrCompInstanceWithoutNode-desc = Es gibt Knoten-Objekte im Diagramm. \
	So haben Sie ein reelles\n Verteilungsdiagramm erhalten. In \
	Verteilungsdiagrammen befinden sich Komponenten\n normalerweise innerhalb \
	Knoten-Objekten.
critics.CrCompInstanceWithoutNode-head = Objekte von Komponenten befinden sich \
	normalerweise innerhalb von Knoten
critics.CrComponentWithoutNode-desc = Es gibt Knoten im Diagramm. So haben Sie \
	ein reales\n Verteilungsdiagramm erhalten. In Verteilungsdiagrammen \
	befinden sich Komponenten\n normalerweise innerhalb von Knoten.
critics.CrComponentWithoutNode-head = Komponenten befinden sich normalerweise \
	innerhalb von Knoten
critics.CrConflictingComposites-desc = Die Kompositionsfunktion (schwarzer \
	Diamand) einer Assoziation zeigt, da\u00df Objekte dieser Klasse \
	Objekte der assoziierten Klasse enthalten k\u00f6nnen. Da jede Instanz \
	h\u00f6chstens in einem anderen Projekt enthalten sein darf, darf jedes \
	Objekt h\u00f6chstens \"Teil\" einer Ist-Teil-von-Assoziation sein.\n\nGutes \
	OO-Design h\u00e4ngt von der Bildung guter Ist-Teil-von-Assoziationen ab.\n\n\
	Zur Beseitigung des Problemes, klicken Sie auf die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie \u00e4ndern von Hand eine Assoziation, um eine \
	Kardinalit\u00e4t von 0..1 oder 1..1 zu erhalten. Oder, Sie verwenden eine \
	andere Art von Aggregation (z.B.: ist ein wei\u00dfer Diamant weniger \
	streng). Oder, Sie entfernen eine der Assoziationen.
critics.CrConflictingComposites-head = Entfernen Sie die \
	konflikttr\u00e4chtige Komposition
critics.CrConsiderSingleton-desc = Diese Klasse hat weder nicht-statische \
	Attribute noch irgendwelche Assoziationen, die von Instanzen dieser Klasse \
	ferngesteuert werden k\u00f6nnen. Das bedeutet, da\u00df jedes Objekt \
	dieser Klasse mit jedem anderen Objekt \u00fcbereinstimmen wird (gleich \
	sein), da es nichts \u00fcber die Objekte geben wird, die sie von anderen \
	Unterscheidbar macht.\n\nUnter diesen Umst\u00e4nden sollten Sie \
	dar\u00fcber nachdenken, ob Sie genau ein Objekt dieser Klasse haben \
	und dies mit Hilfe des \"Singleton\"-Musters ausdr\u00fccklich festlegen \
	sollten. Die Verwendung des \"Singleton\"-Entwurfsmusters kann Zeit und \
	Speicherplatz sparen. In ArgoUML k\u00f6nnen Sie dies erreichen, indem Sie \
	das Stereotyp <<singleton>> f\u00fcr diese Klasse verwenden.\n\nWenn Sie \
	nicht nur ein einziges Objekt haben wollen, sollten Sie Objektvariablen \
	(z.B. nicht-statische Attribute) und/oder gehende Assoziationen \
	definieren, welche die Unterschiede zwischen den Objekten \
	repr\u00e4sentieren.\n\nWenn Sie \"<ocl>self</ocl>\" als Singleton \
	spezifiziert haben, m\u00fcssen Sie die Klasse so definieren, da\u00df es \
	nur ein einziges Objekt geben kann. Dies vervollst\u00e4ndigt den \
	Informationsteil Ihres Entwurfes. Um dies zu erreichen, m\u00fcssen Sie \
	folgendes tun.\n\n1. Ein statisches Attribut (eine Klassenvariable) \
	definieren, welches die Instanz aufnimmt. Dieses mu\u00df daher den Typ \
	\"<ocl>self</ocl>\" aufweisen.\n\n2. Erlauben Sie in \"<ocl>self</ocl>\" \
	nur private Konstruktoren, damit von anderem Code keine neuen Instanzen \
	erzeugt werden k\u00f6nnen. Die Erzeugung des einzigen Objektes \
	k\u00f6nnte durch eine geeignete Hilfs-Operation erfolgen, die diesen \
	privaten Konstruktor genau einmal aufruft.\n\n3. Sorgen Sie daf\u00fcr, \
	da\u00df mindestens ein Konstruktor den Standard-Konstruktor \
	\u00fcberschreibt, soda\u00df der Standardkonstruktor nicht dazu verwendet \
	werden kann, mehrere Instanzen zu erzeugen.\n\nIn Java und C++ haben \
	Konstruktoren per Konvention die gleichen Namen wie die Klasse, sind nicht \
	statisch und geben keinen R\u00fcckgabewert zur\u00fcck. Beachten Sie, \
	da\u00df dies in ArgoUML bedeutet, da\u00df Sie den standardm\u00e4ssig \
	f\u00fcr eine Methode erzeugten R\u00fcckgabewert entfernen m\u00fcssen. \
	ArgoUML wird jede Methode akzeptieren, die diesen Konventionen eines \
	Konstruktors folgen, auch wenn sie nicht mit dem Sterotyp <<create>> oder \
	<<Create>> versehen wurde.
critics.CrConsiderSingleton-head = Sie sollten dar\u00fcber nachdenken, \
	f\u00fcr \"<ocl>self</ocl>\" das \"Singleton\"-Entwurfsmuster zu verwenden.
critics.CrConstructorNeeded-desc = Sie haben bis jetzt keinen Konstruktor \
	f\u00fcr die Klasse \"<ocl>self</ocl>\" definiert. Konstruktoren \
	initialisieren neue Objekte, soda\u00df deren Attribute g\u00fcltige \
	Werte aufweisen. Diese Klasse ben\u00f6tigt wahrscheinlich einen \
	Konstruktor, weil nicht alle seine Attribute Anfangswerte aufweisen. \n\n\
	Das Definieren guter Konstruktoren ist der Schl\u00fcssel f\u00fcr die \
	Etablierung unver\u00e4nderlicher Klassenobjekte. Unver\u00e4nderliche \
	Klassenobjekte sind eine gro\u00dfe Hilfe beim Schreiben stabilen Codes. \
	\n\nZur Problembeseitigung dr\u00fccken Sie die Schaltfl\u00e4che \
	\"Weiter >>\" und f\u00fcgen einen Konstruktor mit Hilfe des \
	kontextsensitiven Pop-Up-Men\u00fcs des Registerblattes \"Eigenschaften\" \
	hinzu. Oder, Sie markieren im Klassendiagramm \"<ocl>self</ocl>\" und \
	verwenden den Men\u00fcpunkt \"Methode hinzuf\u00fcgen\".\n\nEin \
	Konstruktor ist eine Methode mit dem Stereotypen <<create>>.\n\nEin \
	Konstruktor hat per Konvention (Java, C++) den gleichen Namen wie die \
	Klasse, ist nicht statisch und gibt keinen R\u00fcckgabewert zur\u00fcck \
	(das bedeutet, Sie m\u00FCssen den return-Parameter, den ArgoUML \
	standardm\u00e4ssig hinzuf\u00fcgt, entfernen). ArgoUML wird jede Methode \
	akzeptieren, die diesen Konventionen folgt, auch wenn er nicht den \
	Sterotyp <<create>> aufweist.
critics.CrConstructorNeeded-head = Definieren Sie einen Konstruktor f\u00fcr \
	die Klasse \"<ocl>self</ocl>\".
critics.CrConstructorNeeded-ins = Geben Sie den Namen des neuen Konstruktors \
	ein.
critics.CrConstructorNeeded-sug = Neue Operation
critics.CrCrossNamespaceAssoc-desc = Jede Klasse, jede Schnittstelle oder \
	andere Klassifizierungen (<ocl>self</ocl>), die Teil einer Assoziation \
	sind, sollte sich innerhalb des Namensraumes der Assoziation befinden.\n\n\
	Wenn dies nicht der Fall ist, gibt es f\u00FCr die Klassen, Schnittstellen \
	oder anderen Klassifizierungen keine M\u00f6glichkeit, die Referenz zu \
	den anderen mit Hilfe der Assoziation zu benennen.\n\nBeachten Sie, \
	da\u00df dieser Hinweis derzeit nicht den hierarchischen Namensraum \
	interpretiert. Er wird ausgel\u00f6st, wenn die abschliessenden \
	Komponenten des Namensraumes unterschiedlich sind, auch wenn sie sich \
	eine gemeinsame Wurzel teilen. Diesen Hinweis sollten Sie in diesem Licht \
	interpretieren.\nZur Problembeseitigung l\u00f6schen Sie die Assoziation \
	und erzeugen Sie diese erneut in einem Diagramm, dessen Namensraum die \
	Klassen, Schnittstellen und Klassifizierungen einschlie\u00dft.
critics.CrCrossNamespaceAssoc-head = Die Klassifizierung \"<ocl>self</ocl>\" \
	befindet sich nicht im Namensraum dieser Assoziation.
critics.CrDisambigClassName-desc = Jede Klasse und jede Schnittstelle \
	innerhalb eines Paketes mu\u00df einen eindeutigen Namen haben. Es gibt \
	mindestens zwei Elemente in diesem Paket mit dem Namen \"<ocl>self</ocl>\".\
	\n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement \
	f\u00fcr die Codegenerierung, f\u00fcr die Verst\u00e4ndlichkeit und \
	Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die \
	Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren eine der \
	betroffenen Klassen und benutzen das Registerblatt \"Eigenschaften\", um \
	ihren Namen zu \u00e4ndern
critics.CrDisambigClassName-head = W\u00e4hlen Sie einen eindeutigen Namen \
	f\u00fcr \"<ocl>self</ocl>\" aus.
critics.CrDisambigClassName-ins = Ver\u00E4ndern Sie den Namen.
critics.CrDisambigStateName-desc = Jeder Zustand in einem Zustandsautomaten \
	mu\u00df einen eindeutigen Namen haben. Es sind mindestens zwei \
	Zust\u00e4nde in dieser Maschine mit \"<ocl>self</ocl>\" benannt.\n\nDie \
	klare und unzweideutige Benennung ist das Schl\u00fcsselelement f\u00fcr \
	die Codegenerierung, sowie f\u00fcr die Verst\u00e4ndlichkeit und \
	Pflegbarkeit des Entwurfes. \n\nZur Problembeseitigung klicken Sie auf \
	die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie markieren von Hand \
	einen der konflikttr\u00e4chtigen Zust\u00e4nde und verwenden das \
	Registerblatt \"Eigenschaften\", um den Namen zu \u00e4ndern.
critics.CrDisambigStateName-head = W\u00e4hlen Sie einen eindeutigen Namen \
	f\u00fcr \"<ocl>self</ocl>\".
critics.CrDupParamName-desc = Jeder Parameter einer Methode mu\u00df einen \
	eindeutigen Namen haben. \n\nDie klare und unzweideutige Namensgebung ist \
	f\u00FCr die Codegenerierung und zum Erreichen eines klaren und wartbaren \
	Entwurfes erforderlich.\n\nZur Problembeseitigung klicken Sie auf die \
	Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie \u00e4ndern den Namen \
	eines Parameters von Hand.
critics.CrDupParamName-head = Der Parametername kommt doppelt vor.
critics.CrDupRoleNames-desc = Die Assoziation \"<ocl>self</ocl>\" hat zwei \
	Rollen mit dem gleichen Namen. \n\nDie klare und unzweideutige \
	Namensgebung ist ein Schl\u00fcsselelement bei der Codegenerierung, bei \
	der Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \n\nUm dies \
	manuell zu beseitigen, markieren Sie \"<ocl>self</ocl>\" und verwenden \
	Sie das Registerblatt \"Eigenschaften\", um einen oder mehrere der \
	konfliktausl\u00f6senden Rollennamen zu \u00e4ndern.
critics.CrDupRoleNames-head = Duplizieren Sie die Namen der Enden (Rollen) \
	f\u00fcr \"<ocl>self</ocl>\".
critics.CrEmptyPackage-desc = Sie haben bis jetzt noch keine Elemente in das \
	Paket \"<ocl>self</ocl>\" eingef\u00fcgt. Normalerweise enthalten Pakete \
	Gruppen zusammengeh\u00f6render Klassen.\n\nDas Definieren und Verwenden \
	von Paketen ist ein Schl\u00fcsselelement beim Erstellen eines pflegbaren \
	Entwurfes. \n\nUm dieses Problem zu l\u00f6sen, markieren Sie im \
	Navigationsfenster das Paket \"<ocl>self</ocl>\" und f\u00fcgen Diagramme \
	oder Modellelemente, wie Klassen oder Anwendungsf\u00e4lle hinzu. 
critics.CrEmptyPackage-head = F\u00fcgen Sie dem Paket \"<ocl>self</ocl>\" \
	Elemente hinzu
critics.CrFinalSubclassed-desc = Das Schl\u00fcsselwort \"Blatt\" gibt an, \
	dass eine Klasse keine Unterklassen haben soll. Diese Klasse oder \
	Schnittstelle ist als \"Blatt\" markiert und hat Unterklassen.\n\nEine gut \
	durchdachte Klassenhierachie, die potentielle Erweiterungen transportiert \
	und unterst\u00fctzt, ist ein wichtiger Teil eines verst\u00e4ndlichen und \
	wartbaren Entwurfes.\n\nZur Problembeseitigung klicken Sie auf die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren die Klasse von \
	Hand und \u00e4ndern die Basisklasse. Oder, Sie markieren die Basisklasse \
	und benutzen das Registerblatt \"Eigenschaften\", um das Schl\u00fcsselwort \
	\"Blatt\" zu entfernen.
critics.CrFinalSubclassed-head = Entfernen Sie das  Schl\u00fcsselwort \
	\"Blatt\" oder entfernen Sie die Unterklassen
critics.CrForkOutgoingTransition-desc = Der Ursprung von <ocl>self</ocl> ist \
    ein sich gabelnder Pseudozustand, aber sein Ziel ist kein Zustand. Ein \
    sich gabelndes Segment sollte immer einen Zustand als Ziel haben.\n\n\
    Die Definition g\u00FCltiger Transitionen wird ben\u00F6tigt, um \
    das Verhalten als Teil Ihres Entwurfes zu vervollst\u00E4ndigen.\n\n\
    Um dieses Problem zu beseitigen, klicken Sie auf Transition \
    entfernen, indem Sie auf die Transition im Diagramm klicken \
    und anschliessend \"Strg-Entf\" dr\u00FCcken. Sie k\u00F6nnen auch den \
    Ursprung der Transition oder den Zielzustand \u00E4ndern.
critics.CrForkOutgoingTransition-head = Ung\u00FCltiges Ziel f\u00FCr \
	Transition
critics.CrIllegalGeneralization-desc = Modell-Elemente k\u00f6nnen nur von \
	Elementen des gleichen Typs erben. \n\nEine g\u00fcltige \
	Vererbungshierachie ist f\u00fcr die Codegenerierung und f\u00fcr die \
	Korrektheit des Entwurfes erforderlich. \n\nZur Problembeseitigung \
	benutzen Sie die Schaltfl\u00e4che \"N\u00e4chstes >>\". Oder, Sie \
	markieren den Vererbungspfeil und entfernen ihn von Hand.
critics.CrIllegalGeneralization-head = Unerlaubte Vererbung
critics.CrIllegalName-desc = Die Namen von Modellelementen m\u00fcssen aus \
	Folgen von Buchstaben, Ziffern und Unterstrichen bestehen. Sie d\u00fcrfen \
	keine Satzzeichen enthalten.\n\nZur Generierung von \u00fcbersetzbarem \
	Code sind g\u00fcltige Namen erforderlich. \n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren das \
	hervorgehobene Element und verwenden das Registerblatt \"Eigenschaften\", \
	um einen anderen Namen zu vergeben.
critics.CrIllegalName-head = W\u00e4hlen Sie einen g\u00FCltigen Namen f\u00fcr \
	\"<ocl>self</ocl>\"
critics.CrInstanceWithoutClassifier-desc = Instanzen sind mit mindestens einem \
	Bezeichner verbunden, der deren Struktur und Verhalten beschreibt. \ 
	\n\nMarkieren Sie das hervorgehobene Element und verwenden Sie das \
	Eigenschaftsregister, um mindestens einen Bezeichner hinzuzuf\u00FCgen.
critics.CrInstanceWithoutClassifier-head = Bezeichner für die Instanz einstellen
critics.CrInterfaceAllPublic-desc = Schnittstellen sind dazu gedacht, alle \
	Methoden zu spezifizieren, die von den anderen Klassen implementiert \
	werden m\u00fcssen. Sie m\u00fcssen \"public\" sein. \n\nEine \
	wohldurchdachte Sammlung von Schnittstellen ist ein guter Weg, die \
	denkbaren Erweiterungen eines Klassen-Frameworks zu spezifizieren. \n\n\
	Zur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie markieren die Methoden der Schnittstellen von Hand und benutzen \
	das Registerblatt \"Eigenschaften\", um sie \"public\" zu machen.
critics.CrInterfaceAllPublic-head = Die Methoden in einer Schnittstelle \
	m\u00fcssen \"public\" sein
critics.CrInterfaceOperOnly-desc = Schnittstellen sind dazu gedacht, alle \
	Methoden zu spezifizieren, die von den anderen Klassen implementiert \
	werden m\u00fcssen. Sie implementieren diese Methoden nicht selbst und \
	d\u00fcfen keine Attribute haben.\n\nEine wohldurchdachte Sammlung von \
	Schnittstellen ist ein guter Weg, die denkbaren Erweiterungen eines \
	Klassen-Frameworks zu definieren. \n\nZur Problembeseitigung benutzen \
	Sie die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren die \
	Schnittstelle und benutzen das Registerblatt \"Eigenschaften\", um alle \
	Attribute zu entfernen.
critics.CrInterfaceOperOnly-head = Schnittstellen d\u00fcrfen nur Methoden \
	haben
critics.CrInterfaceWithoutComponent-desc = In Verteilungsdiagrammen befinden \
	sich Schnittstellen normalerweise innerhalb von Komponenten
critics.CrInterfaceWithoutComponent-head = Schnittstellen befinden sich \
	normalerweise innerhalb von Komponenten
critics.CrInvalidBranch-desc = Dieser Verzweigungszustand weist eine \
	ung\u00fcltige Anzahl von Transitionen auf. Normalerweise \
	haben Verzweigungszust\u00e4nde mindestens einen kommende und mindestens \
	eine gehende Transition. \n\nDas Definieren korrekter \
	Transitionen wird ben\u00f6tigt, um das Verhalten Ihres \
	Entwurfes zu vervollst\u00e4ndigen. \n\nZur Beseitigung des Problemes \
	f\u00FCgen Sie Transitionen mit Hilfe des Werkzeuges Transition \
	hinzu. 
critics.CrInvalidBranch-head = Wahl-/Verbindungs-Transitionen \
	hinzuf\u00FCgen.
critics.CrInvalidFork-desc = Dieser Verzweigungszustand weist eine \
	ung\u00fcltige Anzahl von Transitionen auf. Normalerweise \
	haben Verzweigungszust\u00e4nde einen kommenden und zwei oder mehrere \
	gehende Transitionen. \n\nDas Definieren korrekter \
	Transitionen wird ben\u00f6tigt, um das Verhalten Ihres \
	Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung f\u00FCgen \
	Sie Transitionen manuell hinzu oder entfernen Sie sie manuell. 
critics.CrInvalidFork-head = \u00c4ndere Verzweigungs-\
	Transitionen
critics.CrInvalidForkTriggerOrGuard-desc = Die markierte Transition \
	sollte keinen Trigger oder W\u00E4chter aufweisen, da es sich um einen \
	sich gabelnde gehende Pseudotransition handelt. Die \
	Transitionen von einer Gabel d\u00FCrfen keine Trigger oder W\u00E4chter \
	aufweisen. \n\nDie Definition von g\u00FCltigen Transitionen wird \
	ben\u00F6tigt, um die Spezifikation des Verhaltens in Ihrem Entwurf zu \
	vervollst\u00E4ndigen.\n\nUm dieses Problem zu beseitigen, entfernen Sie \
	den Trigger indem Sie ihn im Explorer-Fenster markieren und mit dem \
	Rechte-Maus-Klick-Men\u00FC aus dem Modell entfernen. Oder, im Falle eines \
	W\u00E4chters, entfernen Sie ihn, indem Sie im Transitions-W\u00E4chter- \
	Feld auf den W\u00E4chter einen Doppelklick ausf\u00FChren und die \
	Tastenkombination \"Strg-Entf\" dr\u00FCcken.
critics.CrInvalidForkTriggerOrGuard-head = Entfernen Sie den Trigger oder \
	den W\u00E4chter aus der sich gabelnden, gehenden Transition
critics.CrInvalidHistory-desc = Dieser History-Zustand enth\u00E4lt eine \
	ung\u00FCltige Anzahl von Transitionen. Normalerweise haben flache \
	Histories und tiefe Histories meistens eine gehende Transition. \
	\n\nDie Definition von richtigen Transitionen wird \
	ben\u00F6tigt, um die Spezifikation des Verhaltens in Ihrem Entwurf zu \
	vervollst\u00E4ndigen.\n\nUm dieses Problem zu beseitigen, entfernen Sie die \
	Transition, indem Sie auf die Transition im Diagramm \
	klicken und die Tastenkombination \"Strg-Entf\" dr\u00FCcken.
critics.CrInvalidHistory-head = Entfernen Sie separat gehende \
	Transitionen aus historischem Zustand
critics.CrInvalidInitial-desc = Der Anfangszustand weist eine ung\u00FCltige \
	Zahl von Transitionen auf. Normalerweise haben Anfangszust\u00E4nde \
	nur eine gehende Transition. \n\nDie Definition von richtigen \
	Transitionen wird ben\u00F6tigt, um die Spezifikation des Verhaltens \
	in Ihrem Entwurf zu vervollst\u00E4ndigen.\n\nUm dieses Problem zu \
	beseitigen, entfernen Sie die Transition, indem Sie auf die \
	Transition im Diagramm klicken und die Tastenkombination \
	\"Strg-Entf\" dr\u00FCcken.
critics.CrInvalidInitial-head = Entfernen Sie separate gehende \
	Transitionen aus Initialzustand
critics.CrInvalidJoin-desc = Dieser Verkn\u00fcpfungs-Zustand weist eine \
	ung\u00fcltige Anzahl von Transitionen auf. Normalerweise \
	haben Verkn\u00fcpfungszust\u00e4nde zwei oder mehrere kommende und eine \
	gehende Transition. \n\nDas Definieren korrekter \
	Transitionen wird ben\u00f6tigt, um das Verhalten Ihres \
	Entwurfes zu vervollst\u00e4ndigen. \n\nUm dieses Problem zu beseitigen, \
	entfernen Sie die Transitionen oder f\u00FCgen Sie diese manuell \
	hinzu. 
critics.CrInvalidJoin-head = \u00c4ndere Verkn\u00fcpfungs-Transitionen
critics.CrInvalidJoinTriggerOrGuard-desc = Die markierte Transition \
	sollte keinen Trigger oder W\u00E4chter aufweisen, da es sich um eine \
	sich zusammenf\u00FChrende kommende Pseudotransition handelt. Die \
	verkn\u00FCpfenden Transitionen d\u00FCrfen keine Trigger oder W\u00E4chter \
	aufweisen. \n\nDie Definition von g\u00FCltigen Transitionen wird \
	ben\u00F6tigt, um die Spezifikation des Verhaltens in Ihrem Entwurf zu \
	vervollst\u00E4ndigen.\n\nUm dieses Problem zu beseitigen, entfernen Sie \
	den Trigger indem Sie ihn im Explorer-Fenster markieren und mit dem \
	Rechte-Maus-Klick-Men\u00FC aus dem Modell entfernen. Oder, im Falle eines \
	W\u00E4chters, entfernen Sie ihn, indem Sie im Transitions-W\u00E4chter- \
	Feld auf den W\u00E4chter einen Doppelklick ausf\u00FChren und die \
	Tastenkombination \"Strg-Entf\" dr\u00FCcken.
critics.CrInvalidJoinTriggerOrGuard-head = Entfernen Sie den Trigger oder \
	den W\u00E4chter von der verkn\u00FCpfenden, kommenden Transition
critics.CrInvalidPseudoStateTrigger-desc = Die markierte Transition \
	sollte keinen Trigger aufweisen, da es sich hierbei um eine gehende \
	Pseudotransition handelt. Die gehenden Pseudotransitionen \
	d\u00FCrfen keinen Trigger aufweisen. \n\nDie Definition von g\u00FCltigen \
	Transitionen wird ben\u00F6tigt, um die Spezifikation des \
	Verhaltens in Ihrem Entwurf zu vervollst\u00E4ndigen.\n\nUm dieses Problem \
	zu beseitigen, entfernen Sie den Trigger indem Sie ihn im Explorer-Fenster \
	markieren und mit dem Rechte-Maus-Klick-Men\u00FC aus dem Modell entfernen. 
critics.CrInvalidPseudoStateTrigger-head = Entfernen Sie den Trigger von \
	der gehenden Pseudotransition
critics.CrInvalidSynch-desc = Dieser Synchronisationszustand weist ung\u00FCltige \
	Transitionen auf. Normalerweise kommen alle zu einem \
	Synchronisationszustand kommenden Transitionen kommen aus der \
	selben Region und alle gehenden Transitionen zu einem \
	Synchronisationszustand gehen in die selbe Region. Zus\u00E4tzlich m\u00FCssen \
	die Quell- und Zielzustandscontainer der Transitionen \
	nebenl\u00E4ufige Regionen sein. \n\nDie Definition von g\u00FCltigen \
	Transitionen wird ben\u00F6tigt, um die Spezifikation des \
	Verhaltens in Ihrem Entwurf zu vervollst\u00E4ndigen.\n\n Um dieses Problem \
	zu beseitigen, entfernen Sie die Transition, indem Sie die \
	Transition im Diagramm markieren und die Tastenkombination \
	\"Strg-Entf\" dr\u00FCcken. Sie k\u00F6nnen auch die Quell- und Zielzust\u00E4nde \
	der Transitionen \u00E4ndern.
critics.CrInvalidSynch-head = \u00C4ndern Sie die Synchronisationszust\u00E4nde der \
	Transitionen
critics.CrJoinIncomingTransition-desc = Das Ziel von <ocl>self</ocl> ist ein \
    verkn\u00FCpfender Pseudozustand, aber seine Quelle ist kein Zustand. Ein \
    verkn\u00FCpfendes Segment sollte immer von einem Zustand stammen. \n\nDie \
    Definition von g\u00FCltigen Transitionen wird ben\u00F6tigt, um die \
    Spezifikation des Verhaltens in Ihrem Entwurf zu vervollst\u00E4ndigen. \
    \n\n Um dieses Problem zu beseitigen, entfernen Sie die \
    Transition, indem Sie die Transition im Diagramm \
    markieren und die Tastenkombination \"Strg-Entf\" dr\u00FCcken. Sie \
    k\u00F6nnen auch die Quell- und Zielzust\u00E4nde der Transitionen \
    \u00E4ndern.
critics.CrJoinIncomingTransition-head = Ung\u00FCltige Quelle f\u00FCr die \
	Transition
critics.CrLinkWithoutStimulus-desc = In einem Sequenzdiagramm sendet ein \
	Senderobjekt Botschaften\n an ein empfangendes Objekt oder eine \
	empfangende Verbindung. Der Link ist nur die Kommunikationsverbindung, \
	soda\u00df eine Botschaft ben\u00f6tigt wird. 
critics.CrLinkWithoutStimulus-head = Es gibt keine Ausl\u00F6seimpulse f\u00fcr \
	diese Verbindungen
critics.CrMergeClasses-desc = Die markierte Klasse <ocl>self</ocl> partizipiert \
    nur mit einer Assoziation und diese Assoziation hat eine eins-zu-eins- \
    Assoziation mit einer anderen Klasse. Da die Objekte dieser beiden Klassen \
    immer gemeinsam erzeugt oder gel\u00F6scht werden m\u00FCssen, wird das \
    Zusammenf\u00FChren dieser Klassen Ihren Entwurf ohne Verlust der \
    Darstellungsklarheit vereinfachen. Sollten Sie jedoch die \
    zusammengef\u00FChrte Klasse als zu gro\u00DF und zu komplex empfinden, ist \
    es gew\u00F6hnlich besser diese aufzuteilen. \n\nDie Organisation von \
    Klassen zur Verwaltung der Komplexit\u00E4t des Entwurfes ist immer wichtig. \
    Speziell dann, wenn der Entwurf bereits sehr komplex ist. \n\nUm dieses \
    Problem zu l\u00F6sen, f\u00FCgen Sie die Attribute und Operationen der \
    markierten Klasse manuell der anderen Klasse hinzu und l\u00F6schen \
    anschliessend die markierte Klasse aus dem Projekt. 
critics.CrMergeClasses-head = Betrachte verbundene Klassen (<ocl>self</ocl>)
critics.CrMissingAttrName-desc = Jedes Attribut mu\u00df einen Namen haben. \
	\n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement \
	f\u00fcr die Codegenerierung, f\u00fcr die Verst\u00e4ndlichkeit und \
	Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren das Attribut von Hand \
	und benutzen Sie das Registerblatt \"Eigenschaften\", um ihm einen Namen \
	zu geben.
critics.CrMissingAttrName-head = W\u00e4hlen Sie einen Attributnamen aus.
critics.CrMissingAttrName-ins = Geben Sie den Namen dieses Attributes ein.
critics.CrMissingAttrName-sug = Attribut-Name
critics.CrMissingClassName-desc = Jedes Element innerhalb eines Paketes (Klasse, 
	Schnittstelle, Akteur, Anwendungsfall usw.) mu\u00df einen Namen haben. 
	\n\nDie klare und unzweideutige \
	Namensgebung ist ein Schl\u00fcsselelement f\u00fcr die Codegenerierung, \
	sowie f\u00fcr die Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfes. \
	\n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie markieren die Klasse und benutzen das \
	Registerblatt \"Eigenschaften\", um ihr einen Namen zu geben.
critics.CrMissingClassName-head = W\u00e4hlen Sie einen Namen aus.
critics.CrMissingClassName-ins = Geben Sie den Namen dieses Elementes ein.
critics.CrMissingClassName-sug = Klassenname
critics.CrMissingOperName-desc = Jede Methode mu\u00df einen Namen haben. \n\n \
	Die klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement \
	f\u00fcr die Codegenerierung, Verst\u00e4ndlichkeit und Wartbarkeit des \
	Entwurfes. \n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie markieren die Methode von Hand und benutzen das \
	Registerblatt \"Eigenschaften\", um ihr einen Namen zu geben
critics.CrMissingOperName-head = W\u00e4hlen Sie einen Namen f\u00FCr die \
	Operation aus.
critics.CrMissingOperName-ins = Geben Sie den Namen dieses Attributes ein.
critics.CrMissingOperName-sug = Attributname
critics.CrMissingStateName-desc = Jeder Zustand in einem Zustandsautomaten \
	sollte einen Namen haben. \n\nDie klare und unzweideutige Namensgebung \
	ist ein Schl\u00fcsselelement f\u00fcr die Verst\u00e4ndlichkeit und \
	Wartbarkeit des Entwurfes. \n\nZur Problembeseitigung benutzen Sie die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren den Zustand von Hand \
	und benutzen das Registerblatt \"Eigenschaften\", um ihm einen Namen zu \
	geben. Oder, Sie markieren den Zustand und tippen einen Namen ein.
critics.CrMissingStateName-head = W\u00e4hlen Sie einen Namen f\u00FCr den \
	Zustand aus.
critics.CrMissingStateName-ins = Geben Sie den Namen dieses Zustandes ein.
critics.CrMissingStateName-sug = Zustandsname
critics.CrMultiComposite-desc = Ein Objekt in einer Komposition darf nicht \
	zu mehr als einem Kompositionsobjekt geh\u00F6ren. Sie m\u00FCssen die \
	Kardinalit\u00E4t am Ende der Komposition entweder auf 0..1 oder 1..1 (1) \
	\u00E4ndern, damit Ihr Modell Sinn macht.\r\n\r\nErinnern Sie sich, da\u00DF \
	die Komposition die strengere Aggregationsart und die Aggregation \
	schw\u00E4cher ist. Dieses Problem kann mit einem Modell verglichen werden \
	indem ein Finger zur selben Zeit integraler Bestandteil mehrerer H\u00E4nde \
	ist. \r\n\r\nDies ist die zweite Bildungsregel f\u00FCr Assoziationsenden in \
	UML 1.4.
critics.CrMultiComposite-head = Das Assoziationsende einer Komposition hat eine \
	Kardinalit\u00E4t > 1
critics.CrMultipleAgg-desc = Nur eine Funktion einer Assoziation kann vom Typ \
	Aggregation oder vom Typ Komposition sein.\n\nEine klare und konsistente \
	Ist-Teil-von-Hierarchie ist ein Schl\u00fcsselelement f\u00fcr einen \
	klaren Entwurf, \nhandhabbarem Objektspeicher und der Implementierung \
	rekursiver Methoden.\nZur Problembeseitigung markieren Sie die Assoziation \
	und setzen einige der \nAggregationen auf \"Keine\".
critics.CrMultipleAgg-head = Doppelt vorkommende Aggregation.
critics.CrMultipleDeepHistoryStates-desc = Es gibt mehrere, mehrdeutige \
	sehr tief beschriebene Zust\u00E4nde in diesem Zustandsautomaten oder \
	zusammengesetzten Zustand. Normalerweise hat jeder Zustandsautomat \
	oder jeder zusammengesetzte Zustand nur einen beschriebenen Zustand. \ 
	\n\nDie Definition mehrdeutiger Zust\u00E4nde wird ben\u00F6tigt, um das \
	Verhalten Ihres Entwurfes zu vervollst\u00E4ndigen.\n\nUm dieses Problem \
	zu l\u00F6sen, markieren Sie einen der beschriebenen Zust\u00E4nde und l\u00F6schen \
	ihn, durch dr\u00FCcken der Tastenkombination \"Strg-Entf\".
critics.CrMultipleDeepHistoryStates-head = Entfernen Sie sehr tief beschriebene \
	Zust\u00E4nde
critics.CrMultipleInheritance-desc = \"<ocl>self</ocl>\" hat mehrere \
	Basisklassen. Java unterst\u00fctzt aber keine Mehrfachvererbung. Sie \
	m\u00fcssen stattdessen Schnittstellen benutzen. \n\nDiese \u00c4nderung \
	ist erforderlich, bevor Sie Java Code generieren k\u00f6nnen.\n\nZur \
	Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie entfernen (1) eine der Basisklassen von Hand, und (2) definieren \
	optional eine neue Schnittstelle mit den selben Methodendeklarationen und \
	(3) f\u00fcgen diese als Schnittstelle von \"<ocl>self</ocl>\" hinzu, \
	und (4) verschieben Sie die Methodenr\u00fcmpfe der alten Basisklasse \
	nach unten in \"<ocl>self</ocl>\".
critics.CrMultipleInheritance-head = \u00c4ndern Sie Mehrfachvererbungen in \
	Schnittstellen
critics.CrMultipleInitialStates-desc = Es gibt mehrere, mehrdeutige \
	Anfangszust\u00e4nde in diesem Zustandsautomaten. Normalerweise hat jeder \
	Zustandsautomat oder jede Komposition einen Anfangszustand. \n\nDas \
	Definieren eindeutiger Zust\u00e4nde wird ben\u00f6tigt, um die \
	Spezifikation des Verhaltens Ihres Entwurfes zu vervollst\u00e4ndigen.\
	\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie markieren von Hand einen der zus\u00e4tzlichen \
	Anfangszust\u00e4nd und entfernen ihn. 
critics.CrMultipleInitialStates-head = Entfernen Sie zus\u00e4tzliche \
	Anfangszust\u00e4nde
critics.CrMultipleRealization-desc = <ocl>self</ocl> implementiert mehrere \
	Schnittstellen. Obwohl dies in UML legal ist, wird dieser Code nicht in \
	Java \u00fcbersetzt werden k\u00F6nnen. Ersetzen Sie die Mehrfach- \
	Realisierung durch Vererbungen, wenn Sie kompatiblen und fehlerfreien \
	Code erzeugen wollen.
critics.CrMultipleRealization-head = \u00c4ndern Sie die Mehrfach-Realisierung \
	in <ocl>self</ocl> in eine Vererbungsbeziehung.
critics.CrMultipleShallowHistoryStates-desc = Es gibt mehrere, mehrdeutige \
	flach beschriebene Zust\u00E4nde in diesem Zustandsautomaten oder in diesem \
	zusammengesetzten Zustand. Normalerweise hat jeder Zustandsautomat oder \
	zusammengesetzte Zustand nur einen flach beschriebenen Zustand. \
	\n\nDie Definition mehrdeutiger Zust\u00E4nde wird ben\u00F6tigt, um das \
	Verhalten Ihres Entwurfes zu vervollst\u00E4ndigen.\n\nUm dieses Problem \
	zu l\u00F6sen, markieren Sie einen der beschriebenen Zust\u00E4nde und l\u00F6schen \
	ihn, durch dr\u00FCcken der Tastenkombination \"Strg-Entf\".
critics.CrMultipleShallowHistoryStates-head = Entfernen Sie flach beschriebene \
	Zust\u00E4nde
critics.CrNWayAgg-desc = Dreifach- oder Mehrfach-Assoziationen d\u00fcrfen \
	keine Aggregationsenden (Rollen) aufweisen.\n\nAggregation und Komposition \
	werden verwendet, um Teil-vom-Ganzen-Assoziationen darzustellen und \
	k\u00F6nnen per Definition nur auf bin\u00E4re Assoziationen zwischen Modell- \
	Elementen angewendet werden.\n\nZur Problembeseitigung markieren Sie die \
	Assoziation und setzen Sie die Aggregation all dieser Enden (Rollen) auf \
	\"Keine\".
critics.CrNWayAgg-head = Aggregatfunktion in N-fach Assoziation.
critics.CrNameConflict-desc = Namen innerhalb eines Namensraumes m\u00FCssen \
	eindeutig sein (z.B. Pakete). Das Element <ocl>self</ocl> verletzt \
	diese Bedingung. Diese Bedingung ist nicht auf Namen von Assoziationen \
	oder Vererbungen anzuwenden. 
critics.CrNameConflict-head = Durch <ocl>self</ocl> verursachter Namenskonflikt
critics.CrNameConflict-ins = Ver\u00E4ndern Sie den Namen.
critics.CrNameConflictAC-desc = Der Rollenname einer Assoziationsklasse darf \
	nicht in Konflikt mit den Namen von Klassenmerkmalen \
	(z.B. Klassenvariablen) stehen.\n
critics.CrNameConflictAC-head = Der Rollenname widerspricht einem \
	Klassenmerkmal
critics.CrNameConfusion-desc = Namen sollten klar voneinander unterschieden \
	werden k\u00f6nnen. Diese beiden Namen sind so \u00e4hnlich, da\u00df \
	andere Leser verwirrt sein k\u00f6nnten.\n\nEine klare und eindeutige \
	Namensvergabe ist ein Schl\u00fcsselelement f\u00fcr die Code-Generierung \
	und f\u00fcr die Verst\u00e4ndlichkeit und Pflegbarkeit des Entwurfes. \
	\n\nZur Problembeseitigung verwenden Sie die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie markieren die Elemente von Hand und verwenden das \
	Registerblatt \"Eigenschaften\", um deren Namen zu \u00e4ndern. Vermeiden \
	Sie Namen, die sich von anderen nur durch Gro\u00df-/Kleinschreibung, den \
	Gebrauch von Unterstrichen, oder nur durch ein Zeichen unterscheiden.
critics.CrNameConfusion-head = \u00c4ndern Sie den Namen um Verwirrung zu \
	vermeiden
critics.CrNavFromInterface-desc = Assoziationen, die eine Schnittstelle \
	enthalten, k\u00f6nnen von der Schnittstelle nicht gesteuert werden. Dies \
	ist so, weil Schnittstellen nur Methodendeklarationen und keine Zeiger auf \
	andere Objekte enthalten k\u00f6nnen.\n\nDieser Teil des Entwurfes sollte \
	ge\u00e4ndert werden, bevor Sie aus diesem Entwurf Code generieren. Wenn \
	Sie den Code generieren, bevor Sie dieses Problem behoben haben, wird der \
	Code nicht mit dem Entwurf \u00fcbereinstimmen.\n\nZur Problembeseitigung \
	markieren Sie die Assoziation und verwenden Sie das Registerblatt \
	\"Eigenschaften\", um alle Assoziationsenden zu markieren, die NICHT mit \
	der Schnittstelle verbunden sind. Entfernen Sie die Eigenschaft \
	\"Steuerbar\" f\u00fcr jedes dieser Enden. \n\nDie Assoziation sollte dann \
	als d\u00fcnne Pfeilspitze auf die Schnittstelle erscheinen.\n\nWARNUNG: \
	Die aktuelle Version von ArgoUML enth\u00e4lt einen bekannten Fehler. Es \
	erzeugt eine Assoziation zwischen einer Klasse und einer Schnittstelle, \
	die entweder in beiden Richtungen steuerbar, oder nur von der \
	Schnittstelle zur Klasse steuerbar ist. Die L\u00f6sung liegt im Entfernen \
	der Eigenschaft \"steuerbar\" aus dem Klassenende der Assoziation und, \
	sofern notwendig, dem Hinzuf\u00fcgen der Eigenschaft \"steuerbar\" zum \
	Schnittstellenende (steuerbar bezieht sich auf die Steuerbarkeit in \
	RICHTUNG des Endes), wenn dieser Hinweis ausgel\u00f6st wird.
critics.CrNavFromInterface-head = Entfernen Sie die Steuerung aus der \
	Schnittstelle \u00fcber die Assoziation \"<ocl>self</ocl>\"
critics.CrNoAssociations-desc = Sie haben bis jetzt f\u00fcr \
	\"<ocl>self</ocl>\" keine Assoziationen spezifiziert. Normalerweise sind \
	Klassen, Akteure und Anwendungsf\u00e4lle mit anderen assoziiert. \n\nDas \
	Definieren von Assoziationen zwischen Objekten ist ein wichtiger Teil \
	Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen die Assoziationen \
	von Hand hinzu. Dazu klicken Sie auf das Symbol \"Assoziation\" in der \
	Symbolleiste und erzeugen die Assoziationen von und zu \
	\"<ocl>self</ocl>\" per Drag und Drop.
critics.CrNoAssociations-head = F\u00fcgen Sie Assoziationen zu \
	\"<ocl>self</ocl>\" hinzu
critics.CrNoGuard-desc = Die hervorgehobene Transition \
	ist unvollst\u00e4ndig, weil er keinen W\u00e4chter aufweist.  \
	W\u00e4chter-Bedingungen m\u00fcssen erf\u00fcllt sein, bevor die \
	Transition erfolgen kann.  Wenn nur ein W\u00e4chter verwendet \
	wird, erfolgt die Transition, wenn die Bedingung wahr wird.\n\n\
	Dieses Problem mu\u00df gel\u00f6st werden, um den Zustandsautomaten zu \
	vervollst\u00e4ndigen.\n\nZur Problembeseitigung markieren Sie die \
	Transition und verwenden das Registerblatt \"Eigenschaften\". \
	Oder, Sie markieren die Transition und geben den folgenden Text \
	ein:\nW\u00C4CHTER\nDabei ist W\u00C4CHTER ein Ausdruck vom Typ \"boolean\".
critics.CrNoGuard-head = F\u00fcgen Sie der Transition einen \
	W\u00e4chter hinzu
critics.CrNoIncomingTransitions-desc = Zustand \"<ocl>self</ocl>\" hat keine \
	kommende Transition. Normalerweise haben Zust\u00e4nde kommende \
	und gehende Transitionen. \n\nDas Definieren \
	vollst\u00e4ndiger Transitionen wird f\u00fcr die \
	Spezifikation des Verhaltens Ihres Entwurfes ben\u00f6tigt. Ohne kommende \
	Transition kann dieser Zustand niemals erreicht werden.\n\nZur \
	Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie f\u00fcgen Transitionen von Hand durch Anklicken des \
	Transitionswerkzeuges in der Symbolleiste und ziehen von einem anderen \
	Zustand zu \"<ocl>self</ocl>\" hinzu. 
critics.CrNoIncomingTransitions-head = Kommende Transitionen zu \
	\"<ocl>self</ocl>\" hinzuf\u00fcgen.
critics.CrNoInitialState-desc = In diesem Zustandsautomaten oder in dieser \
	Komposition gibt es keinen Anfangszustand. Normalerweise hat jeder \
	Zustandsautomat oder jede Komposition einen Anfangszustand. \n\nDas \
	Definieren eindeutiger Zust\u00e4nde wird ben\u00f6tigt, um das Verhalten \
	Ihres Entwurfes zu spezifizieren.\n\nZur Problembeseitigung klicken Sie \
	auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen einen \
	Anfangszustand von Hand aus der Symbolleiste ein und plazieren diesen \
	im Diagramm. 
critics.CrNoInitialState-head = F\u00fcgen Sie einen Anfangszustand hinzu
critics.CrNoInstanceVariables-desc = Sie haben bis jetzt in \
	\"<ocl>self</ocl>\" noch keine Klassenvariablen spezifiziert. \
	Normalerweise haben Klassen Klassenvariablen, die Zustandsinformationen \
	\u00fcber jede Instanz speichern. Klassen, die nur statische Attribute und \
	Methoden enthalten, sollten das Stereotyp <<utility>> erhalten.\n\nDas \
	Definieren von Klassenvariablen ist erforderlich, um den Informationsteil \
	Ihres Entwurfes zu vervollst\u00e4ndigen. \n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen \
	Klassenvariable durch einen Doppelklick auf \"<ocl>self</ocl>\" im \
	Navigationsfenster hinzu und verwenden das Pop-up-Men\u00fc \"Hinzuf\u00fcgen\", \
	um ein neues Attribut zu erstellen. 
critics.CrNoInstanceVariables-head = F\u00fcgen Sie in \"<ocl>self</ocl>\" \
	Klassenvariablen ein.
critics.CrNoInstanceVariables-ins = Geben Sie den Namen der neuen Variablen ein.
critics.CrNoInstanceVariables-sug = Neues Attribut
critics.CrNoOperations-desc = Sie haben bis jetzt keine Methoden f\u00fcr \
	\"<ocl>self</ocl>\" spezifiziert. Normalerweise enthalten Klassen \
	Methoden, die deren Verhalten definieren.\n\nDas Definieren von Methoden \
	wird ben\u00f6tigt, um das Verhalten Ihres Entwurfes zu \
	vervollst\u00e4ndigen. \n\nZur Problembeseitigung dr\u00fccken Sie die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen Methoden von Hand \
	durch Klicken auf \"<ocl>self</ocl>\" im Navigationsfenster und verwenden \
	des Pop-up-Men\u00fcs \"Hinzuf\u00fcgen\" hinzu.
critics.CrNoOperations-head = Definieren Sie Methoden f\u00fcr die Klasse \
	\"<ocl>self</ocl>\".
critics.CrNoOperations-ins = Geben Sie den Namen der neuen Operation ein.
critics.CrNoOperations-sug = Neue Operation
critics.CrNoOutgoingTransitions-desc = Der Zustand \"<ocl>self</ocl>\" hat \
	keine gehenden Transitionen. Normalerweise \
	haben Zust\u00e4nde kommende und gehende Transitionen \
	(Transitionen). \n\nDas Definieren vollst\u00e4ndiger Transitionen wird \
	f\u00fcr die Spezifikation des Verhaltens Ihres Entwurfes ben\u00f6tigt. \
	Ohne gehende Transition ist dieser Zustand ein \"toter\" Zustand, der \
	niemals verlassen werden kann.\n\nZur Problembeseitigung klicken Sie auf \
	die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen Transitionen \
	von Hand durch Anklicken des Transitionswerkzeuges in der Symbolleiste \
	und ziehen von einem anderen Zustand zu \"<ocl>self</ocl>\" hinzu. 
critics.CrNoOutgoingTransitions-head = Gehende Transitionen zu \
	\"<ocl>self</ocl>\" hinzuf\u00fcgen.
critics.CrNoTransitions-desc = Der Zustand \"<ocl>self</ocl>\" hat keine ein- \
	oder ausgehenden Transitionen. Normalerweise haben \
	Zust\u00e4nde ein- und ausgehende Transitionen. \n\nDie \
	Definition von vollst\u00e4ndigen Zust\u00e4nden und \
	Transitionen ist erforderlich, um das Verhalten Ihres \
	Entwurfs vollst\u00e4ndig zu beschreiben.\n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie f\u00fcgen \
	die Transitionen per Hand hinzu. Dazu klicken Sie auf das \
	Transitionssymbol in der Symbolleiste und erzeugen die \
	Transitionen von und zu \"<ocl>self</ocl>\" per Drag und \
	Drop.
critics.CrNoTransitions-head = Transitionen zu <ocl>self</ocl \
	hinzuf\u00fcgen
critics.CrNoTriggerOrGuard-desc = Die hervorgehobene Transition \
	ist unvollst\u00e4ndig, weil sie kein Signal- oder keinen \
	W\u00e4chter aufweist.  Signale sind Ereignisse, die eine \
	Transition ausl\u00f6sen.  W\u00e4chter m\u00fcssen f\u00fcr \
	die Transition wahr sein, damit er ausgef\u00fchrt werden kann. \
	Wird nur ein W\u00e4chter verwendet, wird die Transition \
	ausgel\u00f6st, wenn die die Bedingung wahr wird.\n\nDieses Problem \
	mu\u00df gel\u00f6st werden, um den Zustandsautomaten zu \
	vervollst\u00e4ndigen.\n\nZur Problembeseitigung markieren Sie die \
	Transition und verwenden das Registerblatt \"Eigenschaften\". \
	Oder, Sie markieren die Transition und geben den folgenden Text \
	ein:\nTRIGGER [W\u00C4CHTER] / AKTION\nDabei ist TRIGGER ein Ereignisname, \
	W\u00C4CHTER ein Ausdruck vom Typ boolean und AKTION eine Aktion, die \
	ausgef\u00fchrt wird, wenn die Transition ausgel\u00f6st wurde.  Alle \
	drei Teile sind optional.
critics.CrNoTriggerOrGuard-head = Der Transition ein Signal oder \
	einen W\u00e4chter hinzuf\u00fcgen.
critics.CrNodeInsideElement-desc = Knoten befinden sich normalerweise nicht \
	innerhalb anderer Elemente. Sie sind zur Laufzeit physische Objekte mit \
	einem Verarbeitungsteil, haben mindestens einen Speicher und oft auch \
	Verarbeitungsf\u00e4higkeiten.
critics.CrNodeInsideElement-head = Knoten haben normalerweise keine \
	H\u00FClle
critics.CrNodeInstanceInsideElement-desc = Knoten-Instanzen befinden sich \
	normalerweise nicht innerhalb anderer Elemente. Sie sind zur Laufzeit \
	physische Objekte mit einem Verarbeitungsteil, haben mindestens einen \
	Speicher und oft auch Verarbeitungsf\u00e4higkeiten.
critics.CrNodeInstanceInsideElement-head = Knoten-Instanzen haben \
	normalerweise keine H\u00FClle
critics.CrNodesOverlap-desc = Einige Objekte in diesem Diagramm \
	\u00fcberlappen und verdecken andere Objekte. Dies kann wichtige \
	Informationen verdecken und es f\u00fcr Menschen schwer \
	verst\u00e4ndlich machen.  Eine ordentliche Erscheinung macht Ihr \
	Diagramm auch f\u00fcr andere Designer, Implementierer und \
	Entscheidungstr\u00e4ger wirkungsvoller. \n\nDas Konstruieren eines \
	verst\u00e4ndlichen Satzes von Klassendiagrammen ist ein wichtiger Teil \
	Ihres Entwurfes.  \n\nUm dieses Problem zu beheben, verschieben Sie die \
	hervorgehobenen Knoten im Diagramm.
critics.CrNodesOverlap-head = Diagramm \"<ocl>self</ocl>\" aufr\u00e4umen
critics.CrNonAggDataType-desc = Datentypen sind keine vollst\u00e4ndigen \
	Klassen und d\u00fcrfen nicht mit Klassen assoziiert werden. Es sei denn, \
	der Datentyp ist Teil einer Komposition (schwarzer Diamand). \n\nEin gutes \
	OO-Design h\u00e4ngt davon ab, \u00fcber welche Entit\u00e4ten \
	vollst\u00e4ndige Objekte abgebildet, und wie die Attribute von Objekten \
	dargestellt werden.\n\nZur Problembeseitigung klicken Sie auf die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie ersetzen den Datentyp von Hand \
	durch eine vollst\u00e4ndige Klasse. Oder, Sie \u00e4ndern die \
	Assoziationsaggregation, um eine vollst\u00e4ndige Klasse \
	zur\u00fcckzuerhalten.\n
critics.CrNonAggDataType-head = Integriere Datentyp
critics.CrObjectWithoutComponent-desc = In Verteilungsdiagrammen befinden sich \
	Objekte normalerweise innerhalb von Komponenten oder Instanzen von \
	Komponenten
critics.CrObjectWithoutComponent-head = Objekte befinden sich normalerweise \
	innerhalb von Komponenten
critics.CrOperNameConflict-desc = Zwei Methoden haben exakt die gleiche \
	Signatur. Methoden m\u00fcssen unterschiedliche Signaturen haben. Eine \
	Signatur ist die Kombination eines Namens mit den Parametertypen der \
	Methode. \n\nDas Vermeiden von identischen Signaturen ist ein \
	Schl\u00fcsselelement bei der Codegenerierung und beim Erstellen eines \
	verst\u00e4ndlichen und wartbaren Entwurfes.\n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren \
	eine der betroffenen Methoden dieser Klasse und \u00e4ndern deren Namen.
critics.CrOperNameConflict-head = \u00c4ndern Sie  in \"<ocl>self</ocl>\" \
	Namen oder Signaturen.
critics.CrOppEndConflict-desc = In \"<ocl>self</ocl>\" haben zwei Funktionen \
	den gleichen Namen. Funktionen m\u00fcssen unterschiedliche Namen haben.\
	\n\nDie klare und unzweideutige Namensgebung ist ein Schl\u00fcsselelement \
	f\u00fcr die Codegenerierung und f\u00fcr das Erstellen eines \
	verst\u00e4ndlichen und wartbaren Entwurfes.\n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren \
	die Funktion am anderen Ende der Assoziation dieser Klasse und \u00e4ndern \
	ihren Namen.
critics.CrOppEndConflict-head = Benennen Sie die Assozationsfunktionen um
critics.CrOppEndVsAttr-desc = Zwei Attribute d\u00FCrfen innerhalb eines \
	Klassifizierers nicht den gleichen Namen aufweisen.\n\nDies ist die zweite \
	Regel f\u00FCr Klassifizierer in UML 1.4.
critics.CrOppEndVsAttr-head = Rolle oder Attribut umbenennen.
critics.CrParamTypeNotImported-desc = Der Typ eines jeden Methodenparameters \
	mu\u00df sichtbar sein und in die Klasse importiert werden, welche die \
	Methode beinhaltet.\n\nDas Importieren von Klassen ist f\u00fcr die \
	Codegenerierung erforderlich. Eine gute Modularisierung von Klassen in \
	Pakete ist ein Schl\u00fcsselelement f\u00fcr einen verst\u00e4ndlichen \
	Entwurf.\n\nZur Problembeseitigung benutzen Sie die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie f\u00fcgen der Klasse, welche die Methode \
	enth\u00e4lt, von Hand eine \"import\"-Anweisung hinzu.
critics.CrParamTypeNotImported-head = Importieren Sie den Parametertyp in die \
	Klasse
critics.CrReservedName-desc = \"<ocl>self</ocl>\" ist ein reserviertes Wort, \
	oder einem reservierten Wort sehr \u00e4hnlich. Die Namen von \
	Modellelementen d\u00fcrfen nicht mit reservierten W\u00f6rtern aus \
	Programmiersprachen oder der UML in Konflikt stehen.\n\nDie Verwendung \
	legaler Namen wird ben\u00f6tigt, um kompatiblen Code generieren zu \
	k\u00f6nnen. \n\nZur Problembeseitigung verwenden Sie die \
	Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren das hervorgehobene \
	Element von Hand und verwenden das Registerblatt \"Eigenschaften\", um \
	einen unterscheidbaren Namen einzugeben.
critics.CrReservedName-head = \u00c4ndern Sie \"<ocl>self</ocl>\" in ein nicht \
	reserviertes Wort
critics.CrReservedName-ins = Ver\u00E4ndern Sie den Namen.
critics.CrReservedNameJava-desc = \"<ocl>self</ocl>\" ist ein reserviertes Wort \
		oder einem reservierte Wort sehr \u00E4hnlich. Die Namen von \
		Modellelementen d\u00FCrfen nicht mit reservierten Worten der \
		Programmiersprache Java kollidieren.\n\nDie Verwendung legaler Namen \
		ist für die Generierung \u00FCbersetzbaren Codes notwendig. \n\n Um \
		dies zu \u00E4ndern, klicken Sie auf die \"Weiter >\"-Schaltfl\u00E4che \
		oder markieren Sie das hervorgehobene Element manuell und geben Sie \
		diesem im Eigenschaftsregister einen neuen Namen.
critics.CrReservedNameJava-head = \u00C4ndern Sie <ocl>self</ocl> in ein nicht \
	reserviertes Wort.
critics.CrReservedNameJava-ins = \u00C4ndern Sie den Namen.
critics.CrReturnWithoutCall-desc = Jede return-Aktion erfordert eine call- \
	oder send-Aktion.\n Aber diese Verbindung hat keine entsprechende \
	call- or send-Aktion.\n
critics.CrReturnWithoutCall-head = Vermisse call(send)-Aktion
critics.CrSeqInstanceWithoutClassifier-desc = Objekte haben eine \
	Klassifizierung.
critics.CrSeqInstanceWithoutClassifier-head = Setze Klassifizierung.
critics.CrSingletonViolatedMissingStaticAttr-desc = \"<ocl>self</ocl>\" wurde \
	mit dem Stereotyp <<singleton>> gekennzeichnet, aber es erf\u00fcllt nicht \
	die f\u00FCr \"Singletons\" geltenden Restriktionen. \nSie hat kein statisches \
	Attribut (eine Klassenvariable), welches die die Instanz aufnimmt.\n\n\
	Immer, wenn Sie eine Klasse mit einem Stereotypen kennzeichnen, sollte die \
	Klasse allen Restriktionen dieses Stereotyps entsprechen. Dies ist ein \
	wichtiger Teil bei der Erstellung eines in-sich-konsistenten und \
	verst\u00e4ndlichen Entwurfes. Die Verwendung von \"Singleton\"- \
	Entwurfsmustern kann Zeit und Speicherplatz sparen.\n\nWenn Sie nicht \
	l\u00e4nger wollen, da\u00df diese Klasse ein \"Singleton\" ist, entfernen \
	Sie das Stereotyp <<singleton>>, indem Sie auf die Klasse klicken und im \
	Registerblatt \"Eigenschaften\" die leere Auswahl in der Stereotypen-Drop- \
	Down-Liste markieren.\n
critics.CrSingletonViolatedMissingStaticAttr-head = Sterotyp \"Singleton\" \
	verletzt. In \"<ocl>self</ocl>\" wird ein statisches Attribut vermisst.
critics.CrSingletonViolatedOnlyPrivateConstructors-desc = \"<ocl>self</ocl>\" \
	wurde mit dem Stereotyp <<singleton>> gekennzeichnet, aber es erf\u00fcllt \
	nicht die f\u00FCr \"Singletons\" geltenden Restriktionen. \nSie darf nur mit \
	\"private\" gekennzeichnete Konstruktoren aufweisen, damit neue Instanzen \
	nicht durch anderen Code erzeugt werden kann.\n\nImmer, wenn Sie eine \
	Klasse mit einem Stereotypen kennzeichnen, sollte die Klasse allen \
	Restriktionen dieses Stereotyps entsprechen. Dies ist ein wichtiger Teil \
	bei der Erstellung eines in-sich-konsistenten und verst\u00e4ndlichen \
	Entwurfes. Die Verwendung von \"Singleton\"-Entwurfsmustern kann Zeit und \
	Speicherplatz sparen.\n\nWenn Sie nicht l\u00e4nger wollen, da\u00df diese \
	Klasse ein \"Singleton\" ist, entfernen Sie das Stereotyp <<singleton>>, \
	indem Sie auf die Klasse klicken und im Registerblatt \"Eigenschaften\" \
	die leere Auswahl in der Stereotypen-Drop-Down-Liste markieren.\n
critics.CrSingletonViolatedOnlyPrivateConstructors-head = Stereotyp \
	\"Singleton\" verletzt, \"<ocl>self</ocl>\" enth\u00e4lt Konstruktor, der \
	nicht mit \"private\" gekennzeichnet ist.
critics.CrStimulusWithWrongPosition-desc = In Sequenzdiagrammen ist die \
	Senderseite der Kommunikationsverbindung dieser Botschaft mit dem Beginn \
	einer Aktivit\u00e4t verbunden. Um ein Sender sein zu k\u00f6nnen, \
	mu\u00df ein Objekt zuerst den Fokus erhalten.
critics.CrStimulusWithWrongPosition-head = Falsche Position dieser Botschaft
critics.CrSubclassReference-desc = Die Klasse <ocl>self</ocl> hat eine Referenz \
	zu einer seiner Unterklassen. Normalerweise sollten alle Unterklassen durch \
	seine Superklasse \"gleich\" behandelt werden. Dies erlaubt das \
	Hinzuf\u00FCgen von Unterklassen ohne die Superklasse \u00E4ndern zu m\u00FCssen. \n\n \
	Die Definition von Assoziationen zwischen Objekten ist ein wichtiger Teil \
	Ihres Entwurfes. Einige Assoziationen sind leichter zu verwalten als andere. \
	Dies ist von den k\u00FCnftigen \u00C4nderungen abh\u00E4ngig. Um dieses Problem zu \
	beseitigen, dr\u00FCcken Sie auf die Schaltfl\u00E4che \"Weiter >>\", oder Sie \
	entfernen die Assoziation manuell, indem Sie diese im Diagramm markieren und \
	die Taste \"Entf\" dr\u00FCcken.
critics.CrSubclassReference-head = Entfernen Sie die Referenz auf die \
	spezielle Unterklasse
critics.CrTooManyAssoc-desc = Es gibt zu viele Assoziationen auf die Klasse \
	\"<ocl>self</ocl>\". Immer, wenn eine Klasse im Entwurf zu zentral wird, \
	wird sie zu einem Engpass bei der Pflege und mu\u00df h\u00e4ufig \
	ver\u00e4ndert werden. \n\nDie Definition von Assoziationen zwischen \
	Objekten ist ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie entfernen \
	die Assoziationen von Hand durch Anklicken einer Assoziation im \
	Navigationsfenster oder Diagramm und dr\u00fccken der Taste \"Entf\". 
critics.CrTooManyAssoc-head = Reduzieren Sie die Assoziationen auf \
	\"<ocl>self</ocl>\"
critics.CrTooManyAttr-desc = In der Klasse \"<ocl>self</ocl>\" gibt es zu \
	viele Attribute.  Immer, wenn eine Klasse im Entwurf zu m\u00e4chtig \
	wird, wird sie zu einem Engpass bei der Pflege und mu\u00df h\u00e4ufig \
	ver\u00e4ndert werden. \n\nDas Definieren von Attributen in Objekten ist \
	ein wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie \
	auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie entfernen Attribute im \
	Diagramm von Hand, durch einen Doppel-Klick auf den Attributbereich der \
	hervorgehobenen Klasse und entfernen der Textzeile des Attributes. 
critics.CrTooManyAttr-head = Reduzieren Sie die Anzahl der Attribute in \
	\"<ocl>self</ocl>\"
critics.CrTooManyClasses-desc = In \"<ocl>self</ocl>\" gibt es zu viele \
	Klassen. \
	Wenn ein Namensraum (z.B. Modell, Paket, Klasse, usw.) zu viele Klassen \
	hat, kann er f\u00FCr den Menschen schwer verst\u00E4ndlich werden. \
	\n\nDas Definieren einer verst\u00E4ndlichen Namensraumstruktur ist ein \
	wichtiger Teil Ihres Designs. \nVerschieben Sie einige Klassen durch \
	anklicken und verschieben im Explorer in einen anderen Namensraum. \
	\n\nDr\u00FCcken Sie die \"Weiter>\"-Schaltfl\u00E4che, um den \
	Ausl\u00F6ser zu \u00E4ndern, der diese Kritik ausl\u00F6st.
critics.CrTooManyClasses-head = Reduzieren Sie die Anzahl der Klassen im \
	Namensraum \"<ocl>self</ocl>\".
critics.CrTooManyOper-desc = In der Klasse \"<ocl>self</ocl>\" gibt es zu \
	viele Methoden.  Immer, wenn eine Klasse in Ihrem Entwurf zu m\u00e4chtig \
	wird, wird sie zu einem Pflegeengpass und mu\u00df h\u00e4ufig \
	ver\u00e4ndert werden. \n\nDas Definieren der Objektmethoden ist ein \
	wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie auf \
	die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie entfernen Methoden im \
	Diagramm von Hand durch einen Doppel-Klick auf den Methodenbereich der \
	hervorgehobenen Klasse und entfernen der Textzeile der Methode. 
critics.CrTooManyOper-head = Reduzieren Sie die Anzahl der Methoden in \
	\"<ocl>self</ocl>\".
critics.CrTooManyStates-desc = Es gibt zu viele Zust\u00e4nde in \
	\"<ocl>self</ocl>\".  Wenn ein Zustandsautomat zu viele Zust\u00e4nde \
	enth\u00e4lt, wird er f\u00fcr Menschen unverst\u00e4ndlich. \n\nDas \
	Definieren eines verst\u00e4ndlichen Satzes von Zust\u00e4nden ist ein \
	wichtiger Teil Ihres Entwurfes. \n\nZur Problembeseitigung klicken Sie \
	auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie entfernen Zust\u00e4nde \
	von Hand durch Anklicken des Zustandes im Navigationsfenster oder im \
	Diagramm und dr\u00fccken der Taste \"Entf\".  Oder, Sie k\u00f6nnen \
	Zust\u00e4nde verschachteln...
critics.CrTooManyStates-head = Reduzieren Sie die Zust\u00e4nde im \
	Zustandsautomaten \"<ocl>self</ocl>\"
critics.CrTooManyTransitions-desc = Es gibt zu viele \
	Transitionen im Zustand \"<ocl>self</ocl>\". \
	Immer wenn ein Zustand im Zustandsautomaten zu m\u00e4chtig wird, wird er \
	zu einem Pflegeengpass und mu\u00df h\u00e4ufig ver\u00e4ndert werden. \
	\n\nDas Definieren von Transitionen zwischen \
	Zust\u00e4nden ist ein wichtiger Teil Ihres Entwurfes. \n\nZur \
	Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie entfernen Transitionen von Hand \
	durch Anklicken einer Transition im Navigationsfenster oder \
	im Diagramm und dr\u00fccken der Taste \"Entf\". 
critics.CrTooManyTransitions-head = Reduzieren Sie Transitionen \
	bei \"<ocl>self</ocl>\"
critics.CrUnconventionalAttrName-desc = Normalerweise beginnen Namen von \
	Attributen mit einem Kleinbuchstaben. Der Name \"<ocl>self</ocl>\" ist \
	ungew\u00f6hnlich, da es nicht mit einem Kleinbuchstaben beginnt.\n\nDas \
	Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die \
	Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur \
	Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und benutzen das \
	Registerblatt \"Eigenschaften\" um einen anderen Namen zu vergeben.
critics.CrUnconventionalAttrName-head = W\u00e4hlen Sie f\u00fcr das Attribut \
	einen besseren Namen.
critics.CrUnconventionalAttrName-ins = Der Attributname sollte mit einem \
	Kleinbuchstaben beginnen.
critics.CrUnconventionalClassName-desc = Normalerweise beginnen Klassennamen \
	mit einem Gro\u00dfbuchstaben. Der Name \"<ocl>self</ocl>\" ist \
	ungew\u00f6hnlich, da er nicht mit einem Gro\u00dfbuchstaben beginnt. \
	\n\nDas Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die \
	Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \n\nZur \
	Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". \
	Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und benutzen das \
	Registerblatt \"Eigenschaften\", um einen anderen Namen zu vergeben.
critics.CrUnconventionalClassName-head = Beginnen Sie den Klassennamen \
	\"<ocl>self</ocl>\" mit einem Gro\u00dfbuchstaben.
critics.CrUnconventionalClassName-ins = Der Klassenname sollte mit einem \
	Gro\u00DFbuchstaben beginnen.
critics.CrUnconventionalOperName-desc = Normalerweise beginnen die Namen von \
	Methoden mit einem Kleinbuchstaben. Der Name \"<ocl>self</ocl>\" ist \
	ungew\u00f6hnlich, da er nicht mit einem Kleinbuchstaben beginnt.\n\nDas \
	Einhalten von sinnvollen Konventionen zur Namensgebung hilft, die \
	Verst\u00e4ndlichkeit und Wartbarkeit des Entwurfs zu verbessern. \
	\n\nZur Problembeseitigung klicken Sie auf die Schaltfl\u00e4che \
	\"Weiter >>\". Oder, Sie markieren \"<ocl>self</ocl>\" von Hand und \
	benutzen das Registerblatt \"Eigenschaften\", um einen anderen Namen zu \
	vergeben.
critics.CrUnconventionalOperName-head = W\u00e4hlen Sie f\u00fcr diese Methode \
	einen besseren Namen aus.
critics.CrUnconventionalOperName-ins = Der Operationsname sollte mit einem \
	Kleinbuchstaben beginnen.
critics.CrUnconventionalOperName-ins-ext = Der Operationsname sollte mit einem \
	Kleinbuchstaben beginnen oder machen Sie ihn zu einem Konstruktor.
critics.CrUnconventionalPackName-desc = Normalerweise werden Paketnamen \
	durchg\u00e4ngig klein geschrieben. Mit Punkten werden \"geschachtelte\" \
	Pakete dargestellt. Der Name \"<ocl>self</ocl>\" ist ungew\u00f6hnlich, da \
	er nicht aus kleinen Buchstaben und Punkten besteht.\n\nDas Einhalten von \
	sinnvollen Konventionen zur Namensgebung hilft die Verst\u00e4ndlichkeit \
	und Wartbarkeit des Entwurfs zu verbessern. \n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie markieren \
	\"<ocl>self</ocl>\" und benutzen das Registerblatt \"Eigenschaften\", um \
	einen anderen Namen zu vergeben.
critics.CrUnconventionalPackName-head = W\u00e4hlen Sie f\u00fcr \
	\"<ocl>self</ocl>\" einen anderen Paketnamen 
critics.CrUnconventionalPackName-ins = \u00E4ndern Sie den Namen des Paketes.
critics.CrUnnavigableAssoc-desc = Die Assoziation \"<ocl>self</ocl>\" ist in \
	keine Richtung steuerbar. Alle Assoziationen sollten mindestens in einer \
	Richtung steuerbar sein.\n\nDie Einstellung der Steuerbarkeit von \
	Assoziationen erlaubt es Ihrem Code auf Daten durch nachfolgenden Zeiger \
	zuzugreifen. \n\nZur Problembeseitigung markieren Sie im Diagramm oder \
	im Navigationsfenster die Assoziation \"<ocl>self</ocl>\", und klicken \
	auf das Registerblatt \"Eigenschaften\". Dann verwenden Sie die unten \
	befindlichen Checkboxen des Eigenschaftsfensters und schalten die \
	Steuerbarkeit ein. 
critics.CrUnnavigableAssoc-head = Machen Sie \"<ocl>self</ocl>\" steuerbar.
critics.CrUselessAbstract-desc = \"<ocl>self</ocl>\" kann das laufende System \
	niemals beeinflussen, da es selbst und auch keine seiner Unterklassen \
	jemals Instanzen bilden k\u00f6nnen. \n\nProblembeseitigung: (1) Sie \
	definieren konkrete Unterklassen, welche die Schnittstelle der Klasse \
	implementieren; oder (2) Sie konkretisieren \"<ocl>self</ocl>\" oder eine \
	seiner existierenden Unterklassen.
critics.CrUselessAbstract-head = Definieren Sie eine konkrete (Unter-)Klasse.
critics.CrUselessInterface-desc = \"<ocl>self</ocl>\" kann niemals verwendet \
	werden, da es keine Klasse implementiert.\n\nZur Problembeseitigung \
	klicken Sie auf die Schaltfl\u00e4che \"Weiter >>\". Oder, Sie verwenden \
	zum definieren von Klassen in der Symbolleiste die Schaltfl\u00e4che \
	\"Klasse\" und die Schaltfl\u00e4che \"Realisieren\", um eine Assoziation \
	von der Klasse zu der hervorgehobenen Schnittstelle herzustellen.
critics.CrUselessInterface-head = Definieren Sie eine Klasse, um \
	\"<ocl>self</ocl>\" zu implementieren
critics.CrUtilityViolated-desc = <ocl>self</ocl> wurde mit dem Stereotyp \
	<<utility>> gekennzeichnet, aber sie stimmt nicht mit den f\u00fcr \
	<<utility>> geltenden Restriktionen \u00fcberein.\nSie enth\u00e4lt \
	Instanz-Attribute oder -Variablen.\n\nWenn Sie wollen, da\u00df diese \
	Klasse nicht l\u00E4nger ein <<utility>> ist, entfernen Sie das Stereotyp \
	<<utility>>, indem Sie auf die Klasse klicken und im Registerblatt \
	\"Eigenschaften\" die leere Auswahl in der Stereotyp-Drop-Down-Liste \
	markieren.\n
critics.CrUtilityViolated-head = Das Sterotyp <<utility>> wurde verletzt, \
	Instanzen k\u00f6nnen erzeugt werden.
critics.CrWrongLinkEnds-desc = In Verteilungsdiagrammen k\u00f6nnen sich \
	Objekte entweder in Komponenten\n oder in Komponenten-Instanzen befinden. \
	Daher ist es nicht m\u00f6glich, zwei Objekte zu haben, die \u00fcber \
	einen Link verbunden sind, w\u00e4hrend ein sich ein Objekt in einer \
	Komponente und \n das andere Objekt in einer Komponenten-Instanz befindet.\
	\n\n\nZur Problembeseitigung entfernen Sie eines der beiden verbundenen \
	Objekte an dieser Stelle und verbinden Sie es mit einem Element, welches \
	den gleichen Typ aufweist wie das andere Objekt.
critics.CrWrongLinkEnds-head = Die Verkn\u00FCpfungsenden haben nicht die \
	gleiche Ebene.
critics.CrZeroLengthEdge-desc = Diese Kante ist zu klein, um leicht gesehen zu \
	werden. Dies kann wichtige Informationen verdecken und es f\u00fcr \
	Menschen schwer verst\u00e4ndlich machen. Eine ordentliche Erscheinung \
	macht Ihr Diagramm auch f\u00fcr andere Designer, Implementierer und \
	Entscheidungstr\u00e4ger wirkungsvoller. \n\nDas Konstruieren eines \
	verst\u00e4ndlichen Satzes von Diagrammen ist ein wichtiger Teil Ihres \
	Entwurfes. \n\nUm dieses Problem zu beheben, verschieben Sie eine oder \
	mehrere Knoten, soda\u00df die hervorgehobenen Kanten l\u00e4nger werden. \
	Oder, Sie klicken in die Mitte der Kante und ziehen diese, um einem neuen \
	Schnittpunkt zu erzeugen.
critics.CrZeroLengthEdge-head = Kante sichtbar machen
critics.WizAddInstanceVariable-ins = Bitte \u00E4ndern Sie den Namen des \
	beanstandeten Modellelementes.
critics.WizAddConstructor-ins = Bitte \u00E4ndern Sie den Namen des \
	beanstandeten Modellelementes.
critics.WizAssocComposite-ins = Bitte w\u00E4hlen Sie eine der folgenden \
	Aggregatoptionen aus: 
critics.WizAssocComposite-option1 = ist eine Komposition von 
critics.WizAssocComposite-option2 = ist eine aufgeteilte Aggregation von 
critics.WizAssocComposite-option3 = Keine Aggregation 
critics.WizBreakCircularComp-ins1 = Bitte w\u00E4hlen Sie eine der folgenden \
	Klassen aus. In den n\u00E4chsten zwei Schritten wird eine Aggregation \
	dieser Klasse aufgehoben. 
critics.WizBreakCircularComp-ins2 = Bitte w\u00E4hlen Sie eine der folgenden \
	Assoziationen aus. In den n\u00E4chsten zwei Schritten wird die Aggregation \
	aufgehoben.
critics.WizBreakCircularComp-ins3 = Sind Sie sicher, da\u00DF Sie diese \
	Aggregation aufheben wollen?
critics.WizBreakCircularComp-from = von
critics.WizBreakCircularComp-to = bis
critics.WizManyNames-ins = \u00C4ndern Sie jeden Namen so ab, da\u00DF er sich \
	signifikant von den anderen unterscheidet. Namen sollten sich durch mehr \
	als ein Zeichen voneinander und nicht nur durch ihre Schreibweise \
	(Gro\u00DF- und Kleinbuchstaben) unterscheiden.
critics.WizMEName-ins = Bitte \u00E4ndern Sie den Namen des beanstandeten \
	Modellelementes.
critics.WizNavigable-ins = Bitte w\u00E4hlen Sie eine der folgenden \
	Navigationsoptionen aus. 
critics.WizNavigable-option1 = Navigierbar in Richtung Start
critics.WizNavigable-option2 = Navigierbar in Richtung Ende 
critics.WizNavigable-option3 = In beide Richtungen Navigierbar 
critics.WizNavigable-option4 = Navigierbar in Richtung auf 
critics.WizNavigable-option5 = Navigierbar in Richtung auf 
critics.WizOperName-options1 = Dies ist wirklich ein Konstruktor. 
critics.WizOperName-options2 = Dies ist kein Konstruktor. 
critics.WizOperName-stereotype = Der Operator ist jetzt ein Konstruktor. 
critics.WizTooMany-ins = Bitte berichtigen Sie die Schwelle entsprechend Ihrer \
	Bed\u00FCrfnisse. Damit können Sie eine Kritik berichtigen, wenn diese ein \
	besonderes Zu bearbeiten-Element erzeugt. 
